// Comprehensive example demonstrating all language features
// This program integrates subroutines, operators, control flow, and recursion

// ===== Utility Subroutines =====

// Calculate absolute value using negation
sub abs(n) {
    if n < 0 {
        return -n;
    }
    return n;
}

// Check if value is in range using boolean operators
sub in_range(val, min, max) {
    return val >= min && val <= max;
}

// Calculate factorial recursively
sub factorial(n) {
    if n <= 1 {
        return 1;
    }
    return n * factorial(n - 1);
}

// Check if number is even (returns 1 for even, 0 for odd)
sub is_even(n) {
    remainder = n - n / 2 * 2;
    return !remainder;  // NOT: converts 0 to 1, non-zero to 0
}

// Safe division with negation handling
sub safe_divide(dividend, divisor) {
    if divisor == 0 {
        return 0;
    }
    result = dividend / divisor;
    return result;
}

// Find first value in range divisible by given number
sub find_divisible(start, end, divisor) {
    current = start;
    while current <= end {
        remainder = current - current / divisor * divisor;
        if remainder == 0 {
            return current;  // Found it, break via return
        }
        current = current + 1;
    }
    return 0;  // Not found
}

// Count numbers in range, skipping multiples of 3
sub count_skip_threes(start, end) {
    count = 0;
    i = start;
    while i <= end {
        remainder = i - i / 3 * 3;
        if remainder == 0 {
            i = i + 1;
            continue;  // Skip multiples of 3
        }
        count = count + 1;
        i = i + 1;
    }
    return count;
}

// ===== Main Program =====

// Test absolute value with negative numbers
x = -15;
abs_x = abs(x);
print abs_x;  // 15

y = 10;
abs_y = abs(y);
print abs_y;  // 10

// Range checking with boolean operators
age = 25;
min_age = 18;
max_age = 65;

if in_range(age, min_age, max_age) {
    print 1;  // In range
} else {
    print 0;
}

// Complex expression with unary and binary operators
val = -5 + 3 * 2;  // -5 + 6 = 1
print val;

// NOT operator in conditional
has_error = 0;
if !has_error {
    print 100;  // No error
}

// Factorial with comparison
fact3 = factorial(3);
fact4 = factorial(4);
print fact3;  // 6
print fact4;  // 24

if fact4 > fact3 {
    print 200;
}

// Even/odd checking with loops and NOT
counter = 5;
while counter > 0 {
    if is_even(counter) {
        print counter;  // Print even numbers: 4, 2
    }
    counter = counter - 1;
}

// Test find_divisible with break-like behavior
first_div_7 = find_divisible(1, 20, 7);
print first_div_7;  // 7

// Test count_skip_threes with continue
count = count_skip_threes(1, 10);
print count;  // 6 (skips 3, 6, 9)

// Direct use of break - find first number over 50
search = 0;
while 1 {
    search = search + 1;
    if search > 50 {
        break;
    }
}
print search;  // 51

// Direct use of continue - print only odd numbers
num = 0;
while num < 6 {
    num = num + 1;
    if is_even(num) {
        continue;  // Skip even numbers
    }
    print num;  // 1, 3, 5
}

// Boolean logic with AND/OR
x = 10;
y = 20;

// Range check using AND
if x > 0 && x < 100 && y > 0 && y < 100 {
    print 300;
}

// Multiple conditions with OR
weekend = 0;
vacation = 1;
sick = 0;

can_rest = weekend == 1 || vacation == 1 || sick == 1;
if can_rest {
    print 400;
}

// Nested conditionals with NOT and comparisons
score = 85;
passing = 60;

if !(score < passing) {  // NOT (score < passing) = score >= passing
    if score >= 90 {
        print 500;  // A
    } else {
        if score >= 80 {
            print 501;  // B
        } else {
            print 502;  // C
        }
    }
} else {
    print 503;  // Fail
}

// Nested loops with boolean operators, negation, and break/continue
i = 3;
total = 0;

while i > 0 && i <= 5 {
    j = 2;
    sum = 0;

    while j > 0 {
        // Skip if j equals 1 in iteration when i is 4
        if i == 4 && j == 1 {
            j = j - 1;
            continue;
        }

        // Use negation in calculation
        value = -(i * -j);  // Simplifies to i * j
        sum = sum + value;
        j = j - 1;
    }

    total = total + sum;
    i = i + 1;
}

print total;  // Modified sum (skips i=4, j=1)

// Safe division with error checking
numerator = 100;
denominator = 5;

result = safe_divide(numerator, denominator);
print result;  // 20

// Division by zero test
bad_result = safe_divide(10, 0);
print bad_result;  // 0 (safe default)

// Complex boolean expression with short-circuit
a = 5;
b = 10;
c = 15;

// (a < b AND b < c) OR a == 0
if a < b && b < c || a == 0 {
    print 600;
}

// Double negation
flag = 5;
result = !!flag;  // Any non-zero becomes 1
print result;  // 1

// Using NOT with AND
enabled = 1;
locked = 0;

if enabled == 1 && !locked {
    print 700;
}

// Arithmetic with multiple negations
x = 5;
y = -3;
z = -x + -y;  // -5 + 3 = -2
print z;

// Comparison with negated values
if -10 < -5 {
    print 800;
}

// While loop with NOT condition
done = 0;
count = 0;
while !done {
    count = count + 1;
    if count >= 3 {
        done = 1;
    }
    print count;
}

// Subroutine calls in boolean expressions
if factorial(3) == 6 && abs(-10) == 10 {
    print 900;
}

// Final complex calculation
final = factorial(4) / 4 + abs(-5) - -2;  // 24/4 + 5 + 2 = 13
print final;

// End marker
print 9999;
